- [C++的伪析构函数](#c的伪析构函数)
  - [问题引入](#问题引入)
  - [详细概述伪析构函数](#详细概述伪析构函数)
  - [生存期结束后访问会有什么问题？](#生存期结束后访问会有什么问题)
  - [总结](#总结)

# C++的伪析构函数

<br>

## 问题引入

我们用下面这段代码引入我们今天的主题：

```cpp
#include <iostream>

template<typename T>
concept is_destruct = requires(T v) { v.~T(); };

struct X {};

int main() {
	std::cout << std::boolalpha << is_destruct<X> << '\n';
	std::cout << std::boolalpha << is_destruct<int> << '\n';
}
```

运行结果:

    true
    true

我们需要先稍微普及一下[**约束与概念吗？**](https://zh.cppreference.com/w/cpp/language/constraints)

我们不详细说，其实这里很简单：**`requires(T v)`**，其复合语句`{}`中的语句（即**要求序列**）是否符合语法，即`v.~T();`是否符合语法，如果符合，返回`true`，反之，返回`false`。

你是否注意到一个问题？

“`T v`，`T`是 **`X`** 我能理解，因为它是一个类类型，有析构函数，所以直接那样写肯定可以。”

“但是为啥 **`int`** 类型也是返回的 **`true`** 符合语法呢？”

“它明明是一个内置的标量类型，按照标准规定不也是说它没有析构构造函数吗？”

**对，以上的想法完全对**

至于如何回答这些疑问？这就是我们今天要说的，**伪析构函数**

<br>

## 详细概述伪析构函数

如果你看过`C++`具名要求中的 [**可析构**](https://zh.cppreference.com/w/cpp/named_req/Destructible)。

你会注意到里面有一句描述：

    拜伪析构函数调用所赐，所有标量类型都满足可析构 (Destructible) 的要求，而数组类型和引用类型则不满足。

看似我们之前的问题已经得到了解决，是因为**伪析构函数**导致的，但是还不够，我们可以写出更多的代码，说出更多的解释。

给出如下代码：

```cpp
#include <iostream>

int main() {
	int x = 1;
	(&x).~decltype(&x)();
	std::cout << x << '\n';
}
```

运行结果:

1

给出以上代码，实际上这是`msvc`和`clang`才可以的，`gcc`无法通过编译。实际上我没有在任何专业点的文档看到这种写法，只是因为这编译器可以，我写出来而已，就当知道这件事了，如果你才刚看到这里，完全不需要在乎，往下看就好了。

```cpp
#include <iostream>

int main() {
	typedef int t;
	t a = 1;
	a.~t();
	std::cout << a << '\n';
}
```

运行结果:

`gcc`   : 0

`msvc`  : 1

`clang` : 1

<br>

好像还是不太明白？

"我明白了，`v.~T()`这个语法通过编译没问题，这是ok的，但是为啥这结果不一样呢？gcc会置空？那么按照标准的规定，应该如何呢？"[文档](https://zh.cppreference.com/w/cpp/language/operator_member_access#.E5.86.85.E5.BB.BA.E7.9A.84.E6.88.90.E5.91.98.E8.AE.BF.E9.97.AE.E8.BF.90.E7.AE.97.E7.AC.A6)

    在表达式 E1.E2 中：
    当 E1 是标量类型 (ScalarType) 而 E2 是一个 ~ 之后跟着代表（移除 cv 限定后）相同类型的类型名或 decltype 说明符，可选地有限定时，它的结果是一种特殊的纯右值，它只能用作函数调用运算符的左操作数，而不能用于其他目的。所构成的函数调用表达式被称为伪析构函数调用（pseudo destructor call）。它不接受任何实参，返回 void，求值 E1 后结束它的结果对象的生存期。这是唯一使 operator. 的左操作数具有非类类型的情形。允许进行伪析构函数调用，使得编写代码时无须了解某个给定类型是否存在析构函数成为可能。

重点就在这句：**求值 E1 后结束它的结果对象的生存期**
调用伪析构函数的时候就结束了对象的生存期。

以及你还可以看到此语法目前的主要目的是
**这是唯一使 operator. 的左操作数具有非类类型的情形。允许进行伪析构函数调用，使得编写代码时无须了解某个给定类型是否存在析构函数成为可能。**

你不能直接`int a{}; a.~int();`，必须得`using` `typedef`给一个类型别名，或者在模板里面的时候。

包括你也可以在`cppreference`的[**生存期**](https://zh.cppreference.com/w/cpp/language/lifetime)里面看到：

    对象的生存期在以下时刻结束：

    如果该对象是非类类型，那么在销毁该对象时（可能经由伪析构函数调用销毁），或者
    如果该对象是类类型，那么在析构函数调用开始时，或者
    该对象所占据的存储被释放，或被不内嵌于它的对象所重用时。

还有一些其他[文档](https://eel.is/c++draft/expr.prim.id.dtor#2)的差不多就不再赘述。

`gcc`的结果不同的问题，我的想法那就是**这是`gcc`的问题，不应该改变值，文档也没提过标量类型调用伪析构函数会改变什么值**。并且更具我以往的经验，当`msvc`和`clang`效果一样而`gcc`不一样的时候，大概率是`gcc`的问题。

但是有一个不得不提，也可能是 **`UB`** 炸了，我相信你会觉得很奇怪，上面那个代码哪里有`UB`吗？这就是下一节要讲的内容了！

<br>

## 生存期结束后访问会有什么问题？

我们上面总是提到了一个事情，**析构函数或伪析构函数会结束生存期**。

那么这就会引出一个问题了，生存期结束后访问会有问题吗？是`UB`吗？

这就是我们要解决的问题。

首先我们继续看之前的`demo`分析：

```cpp
#include <iostream>

int main() {
	typedef int t;
	t a = 1;
	a.~t();//生存期结束
	std::cout << a << '\n';//生存期外，但在存储期
}
```

首先问题的答案是：**这是ub**

根据[文档](https://zh.cppreference.com/w/cpp/language/lifetime)的规定：

    在对象的生存期开始之前但在它将要占据的存储已经分配之后，或者在对象的生存期已经结束之后但它曾占据的存储被重用或释放之前，对代表这个对象的泛左值表达式的以下这些用法是未定义的：

    1.左值向右值转换（比如对接受它的值的函数进行调用），除非正在构造或析构该对象（此时适用不同的规则集合

所以我们先前说的`gcc`的输出不同，其实无非还是在**解释UB**，但是我留下了那个错误的解释，用于警示各位。

## 总结

不过是这么一个小小的问题，依然是可以牵扯到如此之多，如此之详细。

我在很久之前就对这个问题深入了解过，但是当我想准备做成视频写文案讲的时候，我就注意到，不够，不够，还远远不够。

有很多我之前学习的时候忽视的，不在乎的东西。所以我们要严谨。